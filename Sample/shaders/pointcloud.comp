#version 450
layout(local_size_x = 256) in;

layout(std430, set = 0, binding = 0) readonly buffer Triangles {
    vec3 verts[];
};

layout(std430, set = 0, binding = 1) writeonly buffer Points {
    vec4 positions[];
};

layout(push_constant) uniform PC {
    float time;
    uint numTriangles;
} pc;

uint wangHash(uint x) {
    x = (x ^ 61u) ^ (x >> 16u);
    x *= 9u;
    x = x ^ (x >> 4u);
    x *= 0x27d4eb2du;
    x = x ^ (x >> 15u);
    return x;
}

float rand(inout uint seed) {
    seed = wangHash(seed);
    return float(seed & 0x00FFFFFFu) / float(0x01000000u);
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (pc.numTriangles == 0u) return;

    uint seed = idx * 1664525u + 1013904223u;

    uint triIdx = wangHash(seed) % pc.numTriangles;
    uint base = triIdx * 3u;
    vec3 v0 = verts[base + 0u];
    vec3 v1 = verts[base + 1u];
    vec3 v2 = verts[base + 2u];

    float r1 = rand(seed);
    float r2 = rand(seed);
    float sqrtR1 = sqrt(r1);
    float a = 1.0 - sqrtR1;
    float b = sqrtR1 * (1.0 - r2);
    float c = sqrtR1 * r2;
    vec3 pos = a * v0 + b * v1 + c * v2;

    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 n = cross(e1, e2);
    float nlen = length(n);
    if (nlen < 1e-6) n = vec3(0.0, 1.0, 0.0);
    else n /= nlen;

    // Compute two tangent directions perpendicular to normal (stable)
    vec3 tangent = normalize(abs(n.x) < 0.99 ? cross(n, vec3(1,0,0)) : cross(n, vec3(0,1,0)));
    vec3 bitangent = cross(n, tangent);

    float swayPhaseX = rand(seed) * 6.28318;
    float swayPhaseY = rand(seed) * 6.28318;
    float swayFreq  = 0.1 + rand(seed) * 0.4;   // slow
    float swayAmp   = 0.01 + rand(seed) * 0.02;

    // Sway along tangent and bitangent instead of normal
    pos += tangent * sin(pc.time * 2.0 * 3.14159 * swayFreq + swayPhaseX) * swayAmp;
    pos += bitangent * sin(pc.time * 2.0 * 3.14159 * swayFreq + swayPhaseY) * swayAmp;

    positions[idx] = vec4(pos, 1.0);
}
